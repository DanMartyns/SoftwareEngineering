"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", { value: true });
var React = require("react");
var smoothie_1 = require("smoothie");
exports.TimeSeries = smoothie_1.TimeSeries;
function DefaultTooltip(props) {
    if (!props.display)
        return React.createElement("div", null);
    return (React.createElement("div", { style: { userSelect: 'none' } },
        React.createElement("strong", null, props.time),
        props.data ? (React.createElement("ul", null, props.data.map(function (data, i) { return (React.createElement("li", { key: i }, data.value)); }))) : (React.createElement("div", null))));
}
exports.DefaultTooltip = DefaultTooltip;
function seriesOptsParser(opts) {
    var ret = {};
    // Get default RGB values
    var R = opts.r, G = opts.g, B = opts.b;
    if (R === undefined)
        R = 0;
    if (G === undefined)
        G = 0;
    if (B === undefined)
        B = 0;
    if (opts.fillStyle === undefined && R + G + B) {
        opts.fillStyle = {};
    }
    if (opts.strokeStyle === undefined && R + G + B) {
        opts.strokeStyle = {};
    }
    Object.entries(opts).forEach(function (_a) {
        var name = _a[0], val = _a[1];
        // Don't copy these to the final return
        switch (name) {
            case 'data':
            case 'r':
            case 'g':
            case 'b':
                return;
            default:
        }
        // Certain values are ready to go
        switch (typeof val) {
            case 'string':
            case 'number':
            case 'boolean':
                ret[name] = val;
                return;
            default:
        }
        // Otherwise we've got an object
        // Only convert our fancy rgba object to a string for supported members
        if (!(name == 'fillStyle' || name == 'strokeStyle')) {
            ret[name] = val;
            return;
        }
        var _b = val, r = _b.r, g = _b.g, b = _b.b, a = _b.a;
        if (r === undefined)
            r = R;
        if (g === undefined)
            g = G;
        if (b === undefined)
            b = B;
        if (a === undefined) {
            a = name == 'strokeStyle' ? 1 : r + g + b ? 0.2 : 0;
        }
        ret[name] = "rgba(" + r + "," + g + "," + b + "," + a + ")";
    });
    return ret;
}
var SmoothieComponent = /** @class */ (function (_super) {
    __extends(SmoothieComponent, _super);
    function SmoothieComponent(props) {
        var _this = _super.call(this, props) || this;
        _this.state = { tooltip: {} };
        var opts = Object.assign({}, props);
        // SmoothieChart's tooltip injects a div at the end of the page.
        // This will not do. We shall make our own and intercept the data.
        var updateTooltip = function (o) {
            _this.setState(function (state) {
                Object.assign(state.tooltip, o);
                return state;
            });
        };
        opts.tooltipFormatter = function (t, data) {
            updateTooltip({
                time: t,
                data: props.doNotSimplifyData
                    ? data
                    : data.map(function (set) { return ({
                        index: set.index,
                        value: set.value,
                        series: { options: set.series.options },
                    }); }),
            });
            return '';
        };
        // Make boolean for smoothie
        opts.tooltip = !!opts.tooltip;
        var smoothie = new smoothie_1.SmoothieChart(opts);
        var lastDisplay;
        // Intercept the set data
        smoothie.tooltipEl = {
            style: {
                // Intercept when smoothie.js sets tooltipEl.style.display
                set display(v) {
                    if (v === lastDisplay)
                        return;
                    lastDisplay = v;
                    updateTooltip({ display: v == 'block' });
                },
                // Get smoothie's mouse events
                set top(v) {
                    updateTooltip({
                        top: smoothie.mouseY,
                        left: smoothie.mouseX,
                    });
                },
            },
        };
        if (props.series) {
            props.series.forEach(function (series) {
                if (!(series.data instanceof smoothie_1.TimeSeries)) {
                    throw Error('Invalid type passed to series option');
                }
                smoothie.addTimeSeries(series.data, seriesOptsParser(series));
            });
        }
        _this.smoothie = smoothie;
        return _this;
    }
    SmoothieComponent.prototype.componentWillUnmount = function () {
        this.smoothie.stop();
    };
    SmoothieComponent.prototype.render = function () {
        var _this = this;
        var style = {};
        if (this.props.responsive === true) {
            style.width = '100%';
            style.height = this.props.height;
        }
        // Prevent extra pixels in wrapping element
        style.display = 'block';
        style = this.props.style || style;
        var tooltipParentStyle = this.props.tooltipParentStyle || {
            pointerEvents: 'none',
            position: 'absolute',
            left: this.state.tooltip.left,
            top: this.state.tooltip.top,
        };
        var Tooltip = this.props.tooltip;
        if (Tooltip === true) {
            Tooltip = DefaultTooltip;
        }
        var canvas = (React.createElement("canvas", { className: this.props.classNameCanvas || this.props.className, style: style, width: this.props.responsive === true ? undefined : this.props.width, height: this.props.height, ref: function (canv) { return canv && _this.smoothie.streamTo(canv, _this.props.streamDelay); } }));
        var tooltip;
        if (Tooltip) {
            tooltip = (React.createElement("div", { style: tooltipParentStyle, className: this.props.classNameTooltip },
                React.createElement(Tooltip, __assign({}, this.state.tooltip))));
        }
        return (React.createElement("div", { className: this.props.classNameContainer, style: this.props.containerStyle || { position: 'relative' } },
            canvas,
            tooltip));
    };
    SmoothieComponent.prototype.addTimeSeries = function (tsOpts, addOpts) {
        if (addOpts === undefined) {
            addOpts = tsOpts;
            tsOpts = undefined;
        }
        var ts = tsOpts instanceof smoothie_1.TimeSeries ? tsOpts : new smoothie_1.TimeSeries(tsOpts);
        this.smoothie.addTimeSeries(ts, seriesOptsParser(addOpts));
        return ts;
    };
    SmoothieComponent.defaultProps = {
        width: 800,
        height: 200,
        streamDelay: 0,
    };
    return SmoothieComponent;
}(React.Component));
exports.default = SmoothieComponent;
